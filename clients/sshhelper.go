package clients

import (
	"fmt"
	"time"

	"golang.org/x/crypto/ssh"

	"github.com/appleboy/easyssh-proxy"
)

//SSHHelper helper to manage ssh session
type SSHHelper struct {
	ssh *easyssh.MakeConfig
}

//FromServerAccess construct a SSHHelper from a clients.ServerAccess
func FromServerAccess(access *ServerAccess, timeout time.Duration) (*SSHHelper, error) {
	cfg := easyssh.MakeConfig{
		Server:  access.GetAccessIP(),
		User:    access.User,
		Key:     access.Key.PrivateKey,
		Timeout: timeout,
	}
	if access.Gateway != nil {

		cfg.Proxy = easyssh.DefaultConfig{
			Server:  access.Gateway.GetAccessIP(),
			User:    access.Gateway.User,
			Key:     access.Gateway.Key.PrivateKey,
			Timeout: timeout,
		}
	}
	return &SSHHelper{
		ssh: &cfg,
	}, nil

}

//WaitSSHReady wait for sshd ready
func (helper *SSHHelper) WaitSSHReady(timeout time.Duration) error {
	finishedChan := make(chan bool)
	errChan := make(chan error)
	//Connection loop
	go func(finishedChan chan bool, errChan chan error) {
		defer close(finishedChan)
		defer close(errChan)
		for {
			if <-finishedChan {
				break
			}
			session, err := helper.Connect()
			errChan <- err
			if err == nil {
				session.Close()
				break
			}

		}
	}(finishedChan, errChan)
	var err error
	for {
		select {
		//Check error channel
		case err = <-errChan:
			if err == nil {
				return nil
			}
		//Check loop duration
		case <-time.After(timeout):
			finishedChan <- true
			return err
		}
	}
}

//Connect creates a ssh Session
func (helper *SSHHelper) Connect() (*ssh.Session, error) {
	return helper.ssh.Connect()
}

// Stream run command on the remote host
//Returns:
// - cout sends command stdout line by line
// - cerr sends command stderr line by line
// - done sends true when command is complete
// - cmdErr sends the error generated by command (nil if no error)
// - err connection error (nil if no err)
//The ssh sessions and channels will be closed when command is done.
func (helper *SSHHelper) Stream(command string, timeout time.Duration, useSudo bool) (cout, cerr <-chan string, done <-chan bool, cmdErr <-chan error, connErr error) {
	if useSudo {
		command = fmt.Sprintf("%s %s", "sudo", command)
	}
	return helper.ssh.Stream(command, timeout)
}

// Run run command on the remote host
//Returns:
// - outStr collected command output stream
// - errStr collected command error stream
// - sends true when command is complete
// - cmdErr sends the error generated by command (nil if no error)
// - err connection error (nil if no err)
//The ssh sessions and channels will be closed when command is done.
func (helper *SSHHelper) Run(command string, timeout time.Duration, useSudo bool) (outStr string, errStr string, isTimeout bool, err error) {
	if useSudo {
		command = fmt.Sprintf("%s %s", "sudo", command)
	}
	return helper.ssh.Run(command, timeout)
}

//Scp copy a file to the remote hots
func (helper *SSHHelper) Scp(srcFilePath string, dstFilePath string) error {
	return helper.Scp(srcFilePath, dstFilePath)
}
